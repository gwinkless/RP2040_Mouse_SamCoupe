/************************************************************************
  main.c

  Main functions
    RP2040 - USB to Sam Coupe mouse converter
    Copyright (C) 2025 Geoff Winkless
    Copyright (C) 2023 Darren Jones
    Copyright (C) 2017-2020 Simon Inns

  This file is part of RP2040 Mouse based on the original SmallyMouse from Simon Inns.

    RP2040 Mouse is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

  Email: nz.darren.jones@gmail.com

************************************************************************/
#include <stdlib.h>
#include <stdio.h>

#include "pico/stdlib.h"
#include "hardware/clocks.h"
#include "pico/multicore.h"
#include "pico/bootrom.h"
#include "pico/binary_info.h"

// Override default USB pin
//#define PIO_USB_DP_PIN_DEFAULT 8

// Configure RP2040 for slower flash
#define PICO_XOSC_STARTUP_DELAY_MULTIPLIER 64
#define PICO_BOOT_STAGE2_CHOOSE_GENERIC_03H 1

#define VERSION "1.0"

//#include "pio_usb.h"
#include "bsp/rp2040/board.h"
#include "bsp/board_api.h"
#include "tusb.h"
#include "main.h"

#include "hardware/uart.h"
#define UART_ID uart0
#define BAUD_RATE 115200
#define DATA_BITS 8
#define STOP_BITS 1
#define PARITY UART_PARITY_NONE


#include "hardware/pio.h"
#include "hardware/irq.h"

// Cookie's BoaI article says that the original hardware resets after about 30uS
// we'll be kind and make it 40uS
#define SamMouseTimeout_us 40


#define PIO_CLK_HZ 48000000u
#define TIMEOUT_X ((uint32_t)(((SamMouseTimeout_us * (PIO_CLK_HZ/1000000)) / 2)))
// divide CLK_HZ by 1 million because SamMouseTimeout_us is in microseconds
// divide result by 3 if we add an extra 1 tick delay into the jmp pin loop, so each cycle will take 3 ticks
// that means our number will be small enough to fit into 11 bits
// when CLK_HZ is reduced, we don't need to do that
static PIO sam_pio = pio0;
static uint sam_sm = 0;
static void
__attribute__((noinline, long_call, section(".time_critical")))
pio_irq_handler(void);
#include "sam_mouse.pio.h"  // generated by pioasm
auto_init_recursive_mutex(samDeltaMutex);

volatile int16_t samYDelta = 0;
volatile int16_t samXDelta = 0;
volatile uint8_t samButts = 0xf; // we start off with no buttons pressed (they're active-low)
volatile bool mouseLive = false;

volatile uint8_t mousedev_addr;
volatile uint8_t mouseinstance;
volatile uint64_t justmounted = 0; // usb callback sets justmounted to time_us_64() and also sets mouseinstance/dev_addr

volatile bool ledstate = false;

static void 
__attribute__((noinline, long_call, section(".time_critical"))) 
pio_irq_handler(void) {
//  static uint64_t tm = 0;
  static int copyXDelta = 0, copyYDelta = 0;
//  uint64_t newtm;
  if (pio_interrupt_get(sam_pio, 1)) {
// when the PIO completes sending all 8 nibbles it sends irq1, so we clear our copy deltas
    copyYDelta = 0;
    copyXDelta = 0;
  }
  // whether we're in irq0 or irq1 we still send new data
  if (mouseLive) {
    recursive_mutex_enter_blocking(&samDeltaMutex);
    // we add the delta values to our copy because if the last read didn't complete we'll want to remember it
    copyYDelta -= samYDelta; // we negate the Y delta because Sam thinks up is positive, while USB thinks up is negative
    copyXDelta += samXDelta;
    // clear the USB core's idea of the delta values
    samYDelta = 0;
    samXDelta = 0;
    recursive_mutex_exit(&samDeltaMutex);
    if (copyXDelta > 0x7ff) {
      copyXDelta = 0x7ff;
    } else if (copyXDelta < -0x7ff) {
      copyXDelta = -0x7ff;
    }
    if (copyYDelta > 0x7ff) {
      copyYDelta = 0x7ff;
    } else if (copyYDelta < -0x7ff) {
      copyYDelta = -0x7ff;
    }
  } else {
// if the mouse isn't plugged in then just report 1111 for every value    
    copyXDelta = copyYDelta = 0xfff;
  }
// we have to push the timeout value along with the data because there's no other way
// of getting such a large value timeout into a PIO register.
// We can do this 16 bits at a time (5 bits for data, 11 bits for timeout),
// so two pairs in each 32-bit word

#define MAKEFIFOWORD(x,y) (((x)|16)|(TIMEOUT_X<<5)|(((y)|16)<<16)|(TIMEOUT_X<<21))
// we're using GPIO_OVERRIDE_INVERT on the output pins so if we write 0 here it becomes 1 on the output
// so no need to ^0x1f the values
  pio_sm_put_blocking(sam_pio, sam_sm, MAKEFIFOWORD(0x1f, samButts));
  pio_sm_put_blocking(sam_pio, sam_sm, MAKEFIFOWORD((copyYDelta&0xf00)>>8, (copyYDelta&0x0f0)>>4));
  pio_sm_put_blocking(sam_pio, sam_sm, MAKEFIFOWORD(copyYDelta&0x00f, (copyXDelta&0xf00)>>8));
  pio_sm_put_blocking(sam_pio, sam_sm, MAKEFIFOWORD((copyXDelta&0x0f0)>>4, copyXDelta&0x00f));

  if (pio_interrupt_get(sam_pio, 0)) {
    pio_interrupt_clear(sam_pio, 0);
  }
  if (pio_interrupt_get(sam_pio, 1)) {
    pio_interrupt_clear(sam_pio, 1);
  }
}


#ifdef DEBUG
#define DEBUG_PRINT(x) printf x
#define CFG_TUSB_DEBUG 3
#else
#define DEBUG_PRINT(x) \
  do                   \
  {                    \
  } while (0)
#define CFG_TUSB_DEBUG 0
#endif

static void blink_status(uint8_t count)
{
  uint8_t i = 0;
  gpio_put(STATUS_PIN, 0);

  while (i < count)
  {
    sleep_ms(200);
    gpio_put(STATUS_PIN, 1);
    sleep_ms(200);
    gpio_put(STATUS_PIN, 0);
    i++;
  }
}


void core1_main() {
  sleep_ms(10);
  board_init();

  tuh_init(0); // 1 for pio-usb or max3421, 0 for main pico hub

  while (true) {
    tuh_task(); // tinyusb host task
    if (justmounted && justmounted < (time_us_64()-200000)) { //  wait 200ms before mounting
// apparently (according to some tinyusb forum post) we shouldn't be setting these values from the callback, because
// the interface is still enumerating at the point of the callback. So we set justmounted in the callback and do this after a timeout instead.
// Interface protocol (hid_interface_protocol_enum_t)
      justmounted = 0;
      // Set protocol to full report mode for mouse wheel support
      tuh_hid_set_protocol(mousedev_addr, mouseinstance, HID_PROTOCOL_REPORT);
      if (tuh_hid_receive_report(mousedev_addr, mouseinstance)) {
        blink_status(3);
      }
      gpio_put(STATUS_PIN, 1); // Turn status LED on
      mouseLive = true;
    }
  }
}

int 
__attribute__((noinline, long_call, section(".time_critical"))) 
main() {
// when RDMSEL is first pulled active, we copy the mouse state to our copyXXX statics, then send 1111 to the mouse port
// (actually we don't send anything - we let all pins float)
// (the keyboard will override that if any of the cursors or ctrl are held down, but we don't need to worry about that)
// for subsequent reads before the timeout expires we send 1111, buttons, ydelta>>8, (ydelta>>4)&f, ydelta&f, xdelta>>8, (xdelta>>8)&f, xdelta&f, 1111
// if there's longer than 30uS between two reads then we start again
// (note the second 1111 at the start - contrary to cookie's doc, there's two initial 1111 reads)
// perhaps that's how George's joystick works? maybe the first read is the keyboard read, and that can be anything, as long as the second
// read is 1111?
// if we had a second USB connector for a joypad, we could use the first read to write cursors, and the second read could still be 1111

// we could also have multiple USB joysticks (up to 4) if we added a connector to optionally connect to Sam's joystick port - worth
// doing? would people rather use "proper" joysticks?

// it would actually makes more sense to output the next data values to the pins once RDMSel goes inactive, so that
// once it goes active again the data is already waiting. that way we don't need to worry about response times

  set_sys_clock_khz(PIO_CLK_HZ/1000, true);
  stdio_init_all();
// Setup Debug to UART
#ifdef DEBUG
  gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);
  gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);
  uart_init(UART_ID, 2400);
  int __unused actual = uart_set_baudrate(UART_ID, BAUD_RATE);
  uart_set_hw_flow(UART_ID, false, false);
  uart_set_format(UART_ID, DATA_BITS, STOP_BITS, PARITY);
#endif
  DEBUG_PRINT(("\033[2J"));
  DEBUG_PRINT(("****************************************************\r\n"));
  DEBUG_PRINT(("*         RP2040 USB To Sam Coup√© adaptor          *\r\n"));
  DEBUG_PRINT(("*         Copyright 2022 Darren Jones              *\r\n"));
  DEBUG_PRINT(("*         (nz.darren.jones@gmail.com)              *\r\n"));
  DEBUG_PRINT(("*         Copyright 2025 Geoff Winkless            *\r\n"));
  DEBUG_PRINT(("*         (sam@ukku.uk)                            *\r\n"));
  DEBUG_PRINT(("*         Version: %s                             *\r\n", VERSION));
  DEBUG_PRINT(("*         Build Date: %s %s         *\r\n", __DATE__, __TIME__));
  DEBUG_PRINT(("****************************************************\r\n"));
  DEBUG_PRINT(("\r\n"));
  DEBUG_PRINT(("RP2040 USB To Sam Booting.....\r\n"));

  // all USB task run in core1
  multicore_reset_core1();
  DEBUG_PRINT(("Core1 Reset\r\n"));

  multicore_launch_core1(core1_main);
  DEBUG_PRINT(("Core1 Launched\r\n"));
  // Initialise the RP2040 hardware
  initialiseHardware();
  DEBUG_PRINT(("Hardware Initalized\r\n"));
  blink_status(2);
  // Blink Status LED and wait for everything to settle
  // can't believe this (5 seconds) needs to be so long. Also, we don't really care if we run before everything's ready
  blink_status(8);
  sam_mouse_pio_init();
  pio_sm_put_blocking(sam_pio, sam_sm, (TIMEOUT_X << 5) | (TIMEOUT_X << 21));
  pio_sm_put_blocking(sam_pio, sam_sm, (TIMEOUT_X << 5) | (TIMEOUT_X << 21));
  pio_sm_put_blocking(sam_pio, sam_sm, (TIMEOUT_X << 5) | (TIMEOUT_X << 21));
  pio_sm_put_blocking(sam_pio, sam_sm, (TIMEOUT_X << 5) | (TIMEOUT_X << 21));
  
  // hopefully the sam_pio will be all running by now
  while (1) {
    __wfi();
  }
}

void initialiseHardware(void)
{
  // Document pins for picotool
  bi_decl(bi_1pin_with_name(SamMouseBit0_PIN, "Sam Mouse Bit0 Output"));
  bi_decl(bi_1pin_with_name(SamMouseBit1_PIN, "Sam Mouse Bit1 Output"));
  bi_decl(bi_1pin_with_name(SamMouseBit2_PIN, "Sam Mouse Bit2 Output"));
  bi_decl(bi_1pin_with_name(SamMouseBit3_PIN, "Sam Mouse Bit3 Output"));
  bi_decl(bi_1pin_with_name(SamMouseBit4_PIN, "Sam Mouse Bit4 Output"));
  bi_decl(bi_1pin_with_name(RDMSEL_PIN, "Sam Mouse RDMSEL input"));
  bi_decl(bi_1pin_with_name(UART_RX_PIN, "UART RX"));
  bi_decl(bi_1pin_with_name(UART_TX_PIN, "UART TX"));
  bi_decl(bi_1pin_with_name(STATUS_PIN, "Status LED"));

  // Initalize the pins
  gpio_init(SamMouseBit0_PIN);
  gpio_init(SamMouseBit1_PIN);
  gpio_init(SamMouseBit2_PIN);
  gpio_init(SamMouseBit3_PIN);
  gpio_init(SamMouseBit4_PIN);
  gpio_init(RDMSEL_PIN);
  gpio_init(STATUS_PIN);
  DEBUG_PRINT(("Pins initalised\r\n"));

  // Set pin directions
// these 4 start out as INputs because we need them to float when they're non-zero. 
// We set the output value to 0, and use set_dir_masked to set any 0 pins to output
  gpio_set_dir_masked(SamMousePinsMask | (1<<RDMSEL_PIN) | (1<<STATUS_PIN), SamMousePinsMask | (1<<STATUS_PIN)); // mouse and status pins are outbound, RDMSEL is inbound
  gpio_pull_up(RDMSEL_PIN); // the internal pullup is about 50-80kOhm, which won't be anywhere near enough to not require our 300ohm pullup resistor, but let's not fight it at least

  DEBUG_PRINT(("Pin directions set\r\n"));
  gpio_put_masked(SamMousePinsMask, 0);
  gpio_put(STATUS_PIN, 0);

}
//--------------------------------------------------------------------+
// Host HID
//--------------------------------------------------------------------+

// Invoked when device with hid interface is mounted
void tuh_hid_mount_cb(uint8_t dev_addr, uint8_t instance, uint8_t const *desc_report, uint16_t desc_len)
{
  (void)desc_report;
  (void)desc_len;
  DEBUG_PRINT(("USB Device Attached\r\n"));
  if (tuh_hid_interface_protocol(dev_addr, instance) == HID_ITF_PROTOCOL_MOUSE) {
    mousedev_addr = dev_addr;
    mouseinstance = instance;
    justmounted = time_us_64();
  }
}

// Invoked when device with hid interface is un-mounted
void tuh_hid_umount_cb(uint8_t dev_addr, uint8_t instance)
{
  (void)dev_addr;
  (void)instance;
  DEBUG_PRINT(("USB Device Removed\r\n"));
  mouseLive = false;
  gpio_put(STATUS_PIN, 0); // Turn status LED off
  // don't bother changing the interrupt status - we'll just report no movement
}

static void processMouse(uint8_t dev_addr, hid_mouse_report_t const *report)
{
  int16_t tmpsamXDelta, tmpsamYDelta;
  // Blink status LED
  // gpio_put(STATUS_PIN, 0);
  (void)dev_addr;
  // sam driver doesn't have any concept of scroll wheel. we could add it, but software support isn't there
/*  // Handle scroll wheel
  if (report->wheel)
  {
    gpio_init(MB_PIN);
    gpio_set_dir(MB_PIN, GPIO_OUT);
    gpio_put(MB_PIN, 0);
    processMouseMovement(report->wheel, MOUSEY);
    sleep_ms(100);
    DEBUG_PRINT(("Wheel movement %d\r\n", report->wheel));
  }
  else
  {
    gpio_deinit(MB_PIN);
  }
*/
  // Handle mouse buttons
  samButts = ((report->buttons & 1) | ((report->buttons << 1) & 4) | ((report->buttons >> 1) & 2)) ^ 0xf;
// usb mouse buttons are active-high, we want active-low. 
// We swap bits 1 and 2 because USB is left-right-centre, sam is left-centre-right

  // Handle mouse movement
  recursive_mutex_enter_blocking(&samDeltaMutex);
  tmpsamXDelta = samXDelta + ((report->x + 1) >> 2);
  tmpsamYDelta = samYDelta + ((report->y + 1) >> 2);
  // we only report back 12-bit values, so restrict the allowable range
  samXDelta = (tmpsamXDelta > 0x7ff) ? 0x7ff : ((tmpsamXDelta < -0x7ff) ? -0x7ff : (int16_t)tmpsamXDelta);
  samYDelta = (tmpsamYDelta > 0x7ff) ? 0x7ff : ((tmpsamYDelta < -0x7ff) ? -0x7ff : (int16_t)tmpsamYDelta);
  recursive_mutex_exit(&samDeltaMutex);
}

void tuh_hid_report_received_cb(uint8_t dev_addr, uint8_t instance, uint8_t const *report, uint16_t len)
{
  (void)len;
  uint8_t const itf_protocol = tuh_hid_interface_protocol(dev_addr, instance);
  switch (itf_protocol)
  {
  case HID_ITF_PROTOCOL_MOUSE:
    processMouse(dev_addr, (hid_mouse_report_t const *)report);
    break;

  default:
    break;
  }

  // continue to request to receive report
  if (!tuh_hid_receive_report(dev_addr, instance))
  {
    return;
  }
}
